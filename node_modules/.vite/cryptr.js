import {
  crypto_exports,
  init_crypto
} from "./chunk-AECCEHDY.js";
import {
  Buffer,
  __commonJS,
  init_buffer,
  init_virtual_process_polyfill
} from "./chunk-MX5QOG3T.js";

// node_modules/cryptr/index.js
var require_cryptr = __commonJS({
  "node_modules/cryptr/index.js"(exports, module) {
    init_virtual_process_polyfill();
    init_buffer();
    var crypto = (init_crypto(), crypto_exports);
    var algorithm = "aes-256-gcm";
    var ivLength = 16;
    var saltLength = 64;
    var tagLength = 16;
    var tagPosition = saltLength + ivLength;
    var encryptedPosition = tagPosition + tagLength;
    function Cryptr(secret) {
      if (!secret || typeof secret !== "string") {
        throw new Error("Cryptr: secret must be a non-0-length string");
      }
      function getKey(salt) {
        return crypto.pbkdf2Sync(secret, salt, 1e5, 32, "sha512");
      }
      this.encrypt = function encrypt(value) {
        if (value == null) {
          throw new Error("value must not be null or undefined");
        }
        const iv = crypto.randomBytes(ivLength);
        const salt = crypto.randomBytes(saltLength);
        const key = getKey(salt);
        const cipher = crypto.createCipheriv(algorithm, key, iv);
        const encrypted = Buffer.concat([cipher.update(String(value), "utf8"), cipher.final()]);
        const tag = cipher.getAuthTag();
        return Buffer.concat([salt, iv, tag, encrypted]).toString("hex");
      };
      this.decrypt = function decrypt(value) {
        if (value == null) {
          throw new Error("value must not be null or undefined");
        }
        const stringValue = Buffer.from(String(value), "hex");
        const salt = stringValue.slice(0, saltLength);
        const iv = stringValue.slice(saltLength, tagPosition);
        const tag = stringValue.slice(tagPosition, encryptedPosition);
        const encrypted = stringValue.slice(encryptedPosition);
        const key = getKey(salt);
        const decipher = crypto.createDecipheriv(algorithm, key, iv);
        decipher.setAuthTag(tag);
        return decipher.update(encrypted) + decipher.final("utf8");
      };
    }
    module.exports = Cryptr;
  }
});

// dep:cryptr
init_virtual_process_polyfill();
init_buffer();
var cryptr_default = require_cryptr();
export {
  cryptr_default as default
};
//# sourceMappingURL=cryptr.js.map
